Esse repositório deve conter mais um package que usa o framework Emmett (https://event-driven-io.github.io/emmett/overview.html). Nesse caso, deve ser um package que cria um EventStore baseado no Google Firestore. Peço sua ajuda para planejar sua criação e implementação com os seguintes requisitos:

R1: Toda documentação deve ser em inglês;
R2: Ele deve ter como base os packages "emmett-mongodb" (primordialmente!), "emmet-esdb", "emmett-sqlite" e "emmett-postgresql" localizado no repositório oficial do Emmet (https://github.com/event-driven-io/emmett) (src/packages);
R3: A estrutura do repositório deve diferir da estrutura do repositório oficial, separando claramente as pastas "src" e "test";
R4: A ideia é usar o Google Firestore como "event store", mas não com a feature de "projections" (essa feature será feita em um futuro package de Google Realtime DB);
R5: O projeto deve conter testes unitários, de integração e E2E (seguindo a estrutura padrão do Emmett, com APISpecification e APIE2ESpecification);
R6: O projeto deve também conter um exemplo baseado nos samples "expressjs-with-mongodb", "expressjs-with-esdb", "expressjs-with-postgresql", "expressjs-with-sqllite" (disponíveis em https://github.com/event-driven-io/emmett/tree/main/samples/webApi) só que usando emmett-expressjs-with-openapi (https://github.com/emmett-community/emmett-expressjs-with-openapi) e o exemplo de shopping-cart em https://github.com/emmett-community/emmett-expressjs-with-openapi/tree/main/examples/shopping-cart;
R7: Esse exemplo (R6) deve fazer uso de docker compose para os testes E2E que possam exercitar um ambiente local de desenvolvimento;
R8: Os drivers são sempre a facilidae de uso do package em uma aplicação real, sem muito boilerplate;
R9: A estrutura recomendada de armazenamento (no Google Firestore) deve ser: 

## Firestore Structure

The package uses **subcollections** for optimal performance and organization:

### Collections Hierarchy

```
/streams/                                    (root collection)
  {streamName}/                              (document - stream metadata)
    version: number
    createdAt: Timestamp
    updatedAt: Timestamp
    
    /events/                                 (subcollection - stream events)
      {streamVersion}/                       (document ID: "0000000000", "0000000001", etc)
        type: string
        data: object
        metadata: object
        timestamp: Timestamp
        globalPosition: number
        streamVersion: number

/_counters/                                  (system collection)
  global_position/
    value: number
    updatedAt: Timestamp
```

### Example Structure

```
/streams/
  User-1234/
    version: 2
    createdAt: 2025-11-11T02:00:00Z
    updatedAt: 2025-11-11T02:05:00Z
    
    /events/
      0000000000: { type: "UserRegistered", data: {...}, globalPosition: 0 }
      0000000001: { type: "UserSignedIn", data: {...}, globalPosition: 5 }
      0000000002: { type: "UserSignedOut", data: {...}, globalPosition: 12 }

  Order-5678/
    version: 0
    createdAt: 2025-11-11T02:10:00Z
    updatedAt: 2025-11-11T02:10:00Z
    
    /events/
      0000000000: { type: "OrderCreated", data: {...}, globalPosition: 1 }
```

### Why Subcollections?

**Benefits:**
- ✅ **Natural isolation** - Each stream has its own event subcollection
- ✅ **Better performance** - No need to filter by `streamName`
- ✅ **Automatic ordering** - Document IDs provide natural sort order
- ✅ **No composite indexes needed** - Simple queries
- ✅ **Better scalability** - Firestore distributes subcollections efficiently

**No Indexes Required!** The subcollection structure works with Firestore's default indexes.